<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
    <head>
        <title>TODO supply a title</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="jquery-2.1.1.min.js"></script>
        <script src="lodash.min.js"></script>

        <!-- http://leafletjs.com/examples/quick-start.html -->
        <script src="leaflet/leaflet.js"></script>        
        <link rel="stylesheet" href="leaflet/leaflet.css">

    </head>
    <body>
        <style>
            #map { position: fixed; left: 0; top: 0; height: 100%; width: 100% }
            
            .panel {
                background-color: black;
                color: white;
            }
            
            #layermenu { 
                position: fixed; left: 1em; bottom: 1em; width: 25%; height: 25%; 
                overflow-y: scroll; 
                opacity: 0.85;
            }
            body {
                font-family: arial;
                
            }
        </style>
        <div id="map"></div>
        <div id="layermenu" class="panel"></div>
        
        <script>

            var updatePeriodMS = 500;

            var map = L.map('map').setView([51.505, -0.09], 13);

            L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
                attribution: 'attribute this :P mothrefuckers',
                maxZoom: 18
            }).addTo(map);

            var features = { };
            var layer = { };
            
            var geojsonMarkerOptions = {
                radius: 8,
                fillColor: "#ff7800",
                color: "#000",
                weight: 1,
                opacity: 1,
                fillOpacity: 0.8
            };

            var gj = L.geoJson().addTo(map);

            //not used yet:
            var geojsonoption = {
                onEachFeature: function onEachFeature(feature, layer) {
                    // does this feature have a property named popupContent?
                    if (feature.properties && feature.properties.popupContent) {
                        layer.bindPopup(feature.properties.popupContent);
                    }
                },
                pointToLayer: function (feature, latlng) {
                    return L.circleMarker(latlng, geojsonMarkerOptions);
                }
            };
            
            function addFeature(id, f) {
                if (!f.geom)  return;
                if (features[id]) return;
                
                f.type = "Feature";
                f.geometry = f.geom;
                
                
                if (f.geom.type === "point")
                    f.geometry.type = "Point";
                var layer = L.geoJson(f, {
                    /*style: function (feature) {
                        return {color: feature.properties.color};
                    },*/
                    onEachFeature: function (feature, layer) {
                        layer.bindPopup(feature.description);
                    }
                });
                layer.data = f;
                features[id] = layer;
                layer.addTo(map);
            }
            
            function removeFeature(i) {
                features[i].removeFrom(map);
                delete features[i];
            }
            
            function updateGeoJSONFeatures(r) {
                
                for (var i in features) {
                    if (!r[i]) {
                        removeFeature(i);
                    }
                }
                
                for (var i in r) {
                    var f = r[i];
                    addFeature(i, f);
                }
                
                var unknownLayers = { };
                
                visibleLayers = { };
                for (var i in features) {
                    var f = features[i].data;
                    var p = f.path;
                    
                    if (!p) continue;                 
                    
                    var l = visibleLayers;
                    for (var i = 0; i < p.length; i++) {
                        var e = p[i];
                        if (l[e]) {                            
                            l = l[e];
                            l.count = l.count + 1;
                        }
                        else {
                            l = l[e] = { count: 1 };    
                            if (!layer[e]) {
                                unknownLayers[e] = true;
                                layer[e] = {name: '?' };
                            }
                            
                        }
                        
                            
                    }
                    
                    
                }
                
                unknownLayers = _.map(_.keys(unknownLayers), 
                    function(l) { return encodeURIComponent(l); });
                    
                if (unknownLayers.length > 0)
                    updateLayers(unknownLayers, renderLayerSelect);
                else
                    renderLayerSelect();
            }
            
            function renderLayerSelect() {
                console.log(JSON.stringify(visibleLayers, null, 4));
                
                var nh = $('<div/>');
                var nu = $('<ul/>').appendTo(nh);
                
                _.each(visibleLayers, function(v, k) {
                    var layerdata = layer[k];
                    var name = layerdata.name;
                    var count = visibleLayers[k].count;
                    nu.append('<li>' + name + ' ' + count + '</li>');
                });

                $('#layermenu').html(nh);
            }
            
            function updateLayerMetadata(r) {
                for (var i in r) {
                    var l = r[i];
                    layer[i] = l;
                }
                console.log(layer);
            }
            
            function updateLayers(layerIDs, callback) {
                $.getJSON('/layer/meta', {id: JSON.stringify(layerIDs) })

                        .done(function (r) {
                            //console.log('received');
                            //console.log(r);
                            updateLayerMetadata(r);
                            
                            if (callback)
                                callback();
                        })
                        .fail(function (v, m) {
                            console.log('err', v, m);
                        });
                        
            }

            var updateBounds = _.throttle(function (e) {
                var b = map.getBounds();

                var radiusMeters = b.getSouthEast().distanceTo(b.getNorthWest()) / 2.0;
                var lon = b.getCenter().lng;
                var lat = b.getCenter().lat;


                $.getJSON('/geoCircle', {lat: lat, lon: lon, radiusM: radiusMeters})

                        .done(function (r) {
                            //console.log('received');
                            //console.log(r);

                            updateGeoJSONFeatures(r);
                        })
                        .fail(function (v, m) {
                            console.log('err', v, m);
                        });
            }, updatePeriodMS);

            map.on('viewreset', updateBounds);
            map.on('move', updateBounds);
            map.on('resize', updateBounds);

            updateBounds();
        </script>

    </body>
</html>
